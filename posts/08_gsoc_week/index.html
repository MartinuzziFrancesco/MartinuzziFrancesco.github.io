<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GSoC week 8: Reservoir Computing with Cellular Automata Part 2 | Francesco Martinuzzi</title><meta name=keywords content><meta name=description content="Continuing the work started last week we are going to further explore the capabilities of Reservoir Computing using Cellular Automata (CA) as the reservoir. As always a little theorical introduction is given and then we will illustrate the use of the model implemented in ReservoirComputing.jl.
Reservoir Computing with Two Dimensional Cellular Automata Two Dimensional Cellular Automata (Conway&rsquo;s Game of Life) In the previous week we used Elementary CA (ECA) to train our model, and this time we want to see if we are able to obtain similar results using a two dimensional CA."><meta name=author content="Francesco Martinuzzi"><link rel=canonical href=https://martinuzzifrancesco.github.io/posts/08_gsoc_week/><link crossorigin=anonymous href=/assets/css/stylesheet.849fd8bd636f9bdcc8fd3087509c431a61faae78bd735e7ba75e6fd13ec64f83.css integrity="sha256-hJ/YvWNvm9zI/TCHUJxDGmH6rni9c157p15v0T7GT4M=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://martinuzzifrancesco.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://martinuzzifrancesco.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://martinuzzifrancesco.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://martinuzzifrancesco.github.io/apple-touch-icon.png><link rel=mask-icon href=https://martinuzzifrancesco.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="GSoC week 8: Reservoir Computing with Cellular Automata Part 2"><meta property="og:description" content="Continuing the work started last week we are going to further explore the capabilities of Reservoir Computing using Cellular Automata (CA) as the reservoir. As always a little theorical introduction is given and then we will illustrate the use of the model implemented in ReservoirComputing.jl.
Reservoir Computing with Two Dimensional Cellular Automata Two Dimensional Cellular Automata (Conway&rsquo;s Game of Life) In the previous week we used Elementary CA (ECA) to train our model, and this time we want to see if we are able to obtain similar results using a two dimensional CA."><meta property="og:type" content="article"><meta property="og:url" content="https://martinuzzifrancesco.github.io/posts/08_gsoc_week/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-26T18:14:43+02:00"><meta property="article:modified_time" content="2020-07-26T18:14:43+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="GSoC week 8: Reservoir Computing with Cellular Automata Part 2"><meta name=twitter:description content="Continuing the work started last week we are going to further explore the capabilities of Reservoir Computing using Cellular Automata (CA) as the reservoir. As always a little theorical introduction is given and then we will illustrate the use of the model implemented in ReservoirComputing.jl.
Reservoir Computing with Two Dimensional Cellular Automata Two Dimensional Cellular Automata (Conway&rsquo;s Game of Life) In the previous week we used Elementary CA (ECA) to train our model, and this time we want to see if we are able to obtain similar results using a two dimensional CA."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://martinuzzifrancesco.github.io/posts/"},{"@type":"ListItem","position":2,"name":"GSoC week 8: Reservoir Computing with Cellular Automata Part 2","item":"https://martinuzzifrancesco.github.io/posts/08_gsoc_week/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GSoC week 8: Reservoir Computing with Cellular Automata Part 2","name":"GSoC week 8: Reservoir Computing with Cellular Automata Part 2","description":"Continuing the work started last week we are going to further explore the capabilities of Reservoir Computing using Cellular Automata (CA) as the reservoir. As always a little theorical introduction is given and then we will illustrate the use of the model implemented in ReservoirComputing.jl.\nReservoir Computing with Two Dimensional Cellular Automata Two Dimensional Cellular Automata (Conway\u0026rsquo;s Game of Life) In the previous week we used Elementary CA (ECA) to train our model, and this time we want to see if we are able to obtain similar results using a two dimensional CA.","keywords":[],"articleBody":"Continuing the work started last week we are going to further explore the capabilities of Reservoir Computing using Cellular Automata (CA) as the reservoir. As always a little theorical introduction is given and then we will illustrate the use of the model implemented in ReservoirComputing.jl.\nReservoir Computing with Two Dimensional Cellular Automata Two Dimensional Cellular Automata (Conway’s Game of Life) In the previous week we used Elementary CA (ECA) to train our model, and this time we want to see if we are able to obtain similar results using a two dimensional CA. As proposed in [1] we are going to use Conway’s Game of Life [2] (GoL), so a little introduction to this model is essential to proceed.\nConway’s Game of Life (GoL) is an example of two-dimensional CA with a Moore neighborhood with range $r=1$ [3], defined as:\n$$ N^{M}_{(x_0, y_0)} = {(x, y):|x-x_0| \\le r, |y-y_0| \\le r } $$\nwhere $(x_0, y_0)$ is the given cell. In the standard GoL format each cell in the grid can be in either of two states: dead or alive (identified respectively with 0 and 1). The transition rules are determined as follows:\n Any alive cell with fewer than two alive cells in its neighborhood will transition to a dead state in the next generation Any alive cell with two or three alive cells in its neighborhood will remain alive in the next generation Any alive cell with more than three alive neighbors will transition to a dead state in the next generation Any dead cell with three alive neighbors will transition to an alive state in the next generation  This CA shows class 4 behavior, neither completely random nor completely repetitive. It is also capable of universal computation and it’s Turing complete [4].\nWe can obtain a GIF of the system using the package ReservoirComputing and Plots in a couple of lines of code: first let’s import the packages\nusing ReservoirComputing using Plots We can now define the variables for the GoL CA, namely dimensions and generations, and defining the GoL object at the same time:\nsize = 100 generations = 250 @time gol = GameOfLife(rand(Bool, size, size), generations); 0.091884 seconds (8 allocations: 2.394 MiB) and now we can plot the obtiained GoL system:\n@gif for i=1:generations  heatmap(gol.all_runs[:, :, i], color=cgrad([:white,:black]),  legend = :none,  axis=false)  plot!(size=(500,500)) end As we can see, starting from a random position, we obtained an evolving GoL system.\nGame of Life reservoir Architecture Since the data used for testing in the literature is also binary in nature, in order to feed it to the reservoir, the method proposed in [1] was based on randomly projecting the input data into the reservoir, whose size should follow that of the input data. This means that for an input of dimension $L_{in}=4$ the size of the reservoir would have been $m=2 \\times 2$. This procedure was repeated a number $R$ of times, effectively creating $R$ different reservoirs. These reservoirs were then connected and the information was allowed to flow between them, in order to obtain an higher dimensional reservoir. This architecture has showed the capability to correctly solve the 5 bit and 20 bit memory task.\nIn the implementation in ReservoirComputing.jl we want to propose an expansion of the encoding method, also capable of solving the 5 bit memory task. Following intuitions given by more recent papers in the field of ReCA, in particular [5] and [6], we decided to input the data to the reservoir using $T$ random projections into an higher dimension matrix. This way the initial state has room to expand and memory of the precedent state is conserved. The procedure is similar to that described by [1], and is illustrated in the figure.\nLet $\\text{X}_1$ be the first input vector. This will be randomly mapped onto a matrix of zeros $T$ times using a fixed mapping scheme $[\\text{P}_1, \\text{P}_2, …, \\text{P}_{\\text{R}}]$ in order to form the initial configuration $\\text{A}_0^{(1)}$ for the GoL. The transition function $Z$, the rules of GoL, is then applied for $I$ generations:\n$$\\text{A}_{1}^{(1)}=\\text{Z}(\\text{A}_0^{(1)})$$\n$$ \\text{A}_{2}^{(1)} = \\text{Z}(\\text{A}_{1}^{(1)}) $$\n$$ \\vdots $$\n$$ \\text{A}_{\\text{I}}^{(1)} = \\text{Z}(\\text{A}_{\\text{I}-1}^{(1)}) $$\nThis constitutes the evolution of the CA given the input $\\text{X}_1$. In order to create the state vector we need to vectorize and concatenate the matrices we obtained. Identifying with $\\text{A}_{0, 1}^{(1)}$ the first column of $\\text{A}_0^{(1)}$, let $c$ be the total number of columns of $\\text{A}_0^{(1)}$, then the vectorization of $\\text{A}_0^{(1)}$ will be\n$$\\text{v}\\text{A}_0^{(1)} = [\\text{A}_{0, 1}^{(1)}, \\text{A}_{0, 2}^{(1)}, …, \\text{A}_{0, c}^{(1)}]$$\nThis procedure is done for every timestep $I$, and at the end the vector state $\\textbf{x}^{(1)}$ will be\n$$\\textbf{x}^{(1)} = [\\text{v}\\text{A}_0^{(1)}, \\text{v}\\text{A}_1^{(1)}, …, \\text{v}\\text{A}_{I}^{(1)}]$$\nAn illustration of this process can be seen in figure.\nTo feed the second input vector $\\text{X}_2$ we use the same mapping created in the first step. Instead of using an initial empty matrix this time we will project the input over the matrix representing the last evolution of the prior step, $\\text{A}_{\\text{I}}^{(1)}$. The matrix thus obtained is evolved as described above, to obtain the state vectors for the second input vector. This procedure is repeated for every input vector.\nThe training is carried out using Ridge Regression.\nExample For example we will try to reproduce the 5 bit memory task, described last week. If you want to follow along and experiment with the model, the data can be found here: the 5bitinput.txt is the input data and the 5bitoutput is the desired output. To read the data we can use the following\nusing DelimitedFiles  input = readdlm(\"./5bitinput.txt\", ',', Int) output = readdlm(\"./5bitoutput.txt\", ',', Int) Now that we have the data we can train the model and see if it is capable of solving the 5 bit memory task with a distractor period of 200.\nusing ReservoirComputing  reca = RECA_TwoDim(input, 30, 10, 110) W_out = ESNtrain(reca, 0.001; train_data = convert(AbstractArray{Float64}, output)) reca_output = RECATDdirect_predict_discrete(reca, W_out, input) reca_output == output true It seems that for architecture used in this example the task is easily solvable. A more deep investigation can be made iterating over different values of reservoir size, permutations and generations, but it can take some time. The results for 100 runs for some of the combinations are given in the table below:\nwhere (n, m) stands for n = generations and m = permutations. The sizes chosen for the system are 26, 28 and 30. As we can see for some of these parameters the 5 bit memory task is solved 100 times out of 100 runs.\nAs always, if you have any questions regarding the model, the package or you have found errors in my post, please don’t hesitate to contact me!\nDocumentation [1]Yilmaz, Ozgur. “Reservoir computing using cellular automata.” arXiv preprint arXiv:1410.0162 (2014).\n[2]Gardner, Martin. “Mathematical games: The fantastic combinations of John Conway’s new solitaire game “life”.” Scientific American 223.4 (1970): 120-123.\n[3]Weisstein, Eric W. “Moore Neighborhood.” From MathWorld–A Wolfram Web Resource. https://mathworld.wolfram.com/MooreNeighborhood.html\n[4]Wolfram, Stephen. A new kind of science. Vol. 5. Champaign, IL: Wolfram media, 2002.\n[5]Margem, Mrwan, and Osman S. Gedik. “Feed-forward versus recurrent architecture and local versus cellular automata distributed representation in reservoir computing for sequence memory learning.” Artificial Intelligence Review (2020): 1-30.\n[6]Nichele, Stefano, and Andreas Molund. “Deep reservoir computing using cellular automata.” arXiv preprint arXiv:1703.02806 (2017).\n","wordCount":"1207","inLanguage":"en","datePublished":"2020-07-26T18:14:43+02:00","dateModified":"2020-07-26T18:14:43+02:00","author":{"@type":"Person","name":"Francesco Martinuzzi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://martinuzzifrancesco.github.io/posts/08_gsoc_week/"},"publisher":{"@type":"Organization","name":"Francesco Martinuzzi","logo":{"@type":"ImageObject","url":"https://martinuzzifrancesco.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://martinuzzifrancesco.github.io/ accesskey=h title="Francesco Martinuzzi (Alt + H)">Francesco Martinuzzi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://martinuzzifrancesco.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://martinuzzifrancesco.github.io/research/ title=Research><span>Research</span></a></li><li><a href=https://martinuzzifrancesco.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>GSoC week 8: Reservoir Computing with Cellular Automata Part 2</h1><div class=post-meta><span title='2020-07-26 18:14:43 +0200 CEST'>July 26, 2020</span>&nbsp;·&nbsp;Francesco Martinuzzi</div></header><div class=post-content><p>Continuing the work started <a href=https://martinuzzifrancesco.github.io/posts/07_gsoc_week/>last week</a> we are going to further explore the capabilities of Reservoir Computing using Cellular Automata (CA) as the reservoir. As always a little theorical introduction is given and then we will illustrate the use of the model implemented in ReservoirComputing.jl.</p><h1 id=reservoir-computing-with-two-dimensional-cellular-automata>Reservoir Computing with Two Dimensional Cellular Automata<a hidden class=anchor aria-hidden=true href=#reservoir-computing-with-two-dimensional-cellular-automata>#</a></h1><h2 id=two-dimensional-cellular-automata-conways-game-of-life>Two Dimensional Cellular Automata (Conway&rsquo;s Game of Life)<a hidden class=anchor aria-hidden=true href=#two-dimensional-cellular-automata-conways-game-of-life>#</a></h2><p>In the previous week we used Elementary CA (ECA) to train our model, and this time we want to see if we are able to obtain similar results using a two dimensional CA. As proposed in <a href=#1>[1]</a> we are going to use Conway&rsquo;s Game of Life <a href=#2>[2]</a> (GoL), so a little introduction to this model is essential to proceed.</p><p>Conway&rsquo;s Game of Life (GoL) is an example of two-dimensional CA with a Moore neighborhood with range $r=1$ <a href=#2>[3]</a>, defined as:</p><p>$$ N^{M}_{(x_0, y_0)} = {(x, y):|x-x_0| \le r, |y-y_0| \le r } $$</p><p>where $(x_0, y_0)$ is the given cell. In the standard GoL format each cell in the grid can be in either of two states: dead or alive (identified respectively with 0 and 1). The transition rules are determined as follows:</p><ul><li>Any alive cell with fewer than two alive cells in its neighborhood will transition to a dead state in the next generation</li><li>Any alive cell with two or three alive cells in its neighborhood will remain alive in the next generation</li><li>Any alive cell with more than three alive neighbors will transition to a dead state in the next generation</li><li>Any dead cell with three alive neighbors will transition to an alive state in the next generation</li></ul><p>This CA shows class 4 behavior, neither completely random nor completely repetitive. It is also capable of universal computation and it&rsquo;s Turing complete <a href=#4>[4]</a>.</p><p>We can obtain a GIF of the system using the package ReservoirComputing and Plots in a couple of lines of code: first let&rsquo;s import the packages</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>using</span> ReservoirComputing
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Plots
</span></span></code></pre></div><p>We can now define the variables for the GoL CA, namely dimensions and generations, and defining the GoL object at the same time:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span>size <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>generations <span style=color:#f92672>=</span> <span style=color:#ae81ff>250</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@time</span> gol <span style=color:#f92672>=</span> GameOfLife(rand(<span style=color:#66d9ef>Bool</span>, size, size), generations);
</span></span></code></pre></div><pre tabindex=0><code>0.091884 seconds (8 allocations: 2.394 MiB)
</code></pre><p>and now we can plot the obtiained GoL system:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#a6e22e>@gif</span> <span style=color:#66d9ef>for</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span>generations
</span></span><span style=display:flex><span>    heatmap(gol<span style=color:#f92672>.</span>all_runs[<span style=color:#f92672>:</span>, <span style=color:#f92672>:</span>, i], color<span style=color:#f92672>=</span>cgrad([<span style=color:#e6db74>:white</span>,<span style=color:#e6db74>:black</span>]),
</span></span><span style=display:flex><span>    legend <span style=color:#f92672>=</span> <span style=color:#e6db74>:none</span>,
</span></span><span style=display:flex><span>    axis<span style=color:#f92672>=</span>false)
</span></span><span style=display:flex><span>    plot!(size<span style=color:#f92672>=</span>(<span style=color:#ae81ff>500</span>,<span style=color:#ae81ff>500</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p><img loading=lazy src=https://user-images.githubusercontent.com/10376688/88486631-53167b80-cf7f-11ea-8dd9-aa6e848f278c.gif alt=tmp></p><p>As we can see, starting from a random position, we obtained an evolving GoL system.</p><h2 id=game-of-life-reservoir-architecture>Game of Life reservoir Architecture<a hidden class=anchor aria-hidden=true href=#game-of-life-reservoir-architecture>#</a></h2><p>Since the data used for testing in the literature is also binary in nature, in order to feed it to the reservoir, the method proposed in <a href=#1>[1]</a> was based on randomly projecting the input data into the reservoir, whose size should follow that of the input data. This means that for an input of dimension $L_{in}=4$ the size of the reservoir would have been $m=2 \times 2$. This procedure was repeated a number $R$ of times, effectively creating $R$ different reservoirs. These reservoirs were then connected and the information was allowed to flow between them, in order to obtain an higher dimensional reservoir. This architecture has showed the capability to correctly solve the 5 bit and 20 bit memory task.</p><p>In the implementation in ReservoirComputing.jl we want to propose an expansion of the encoding method, also capable of solving the 5 bit memory task. Following intuitions given by more recent papers in the field of ReCA, in particular <a href=#5>[5]</a> and <a href=#6>[6]</a>, we decided to input the data to the reservoir using $T$ random projections into an higher dimension matrix. This way the initial state has room to expand and memory of the precedent state is conserved. The procedure is similar to that described by <a href=#1>[1]</a>, and is illustrated in the figure.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/10376688/88486877-30856200-cf81-11ea-986b-555291eabeff.png alt=encoding></p><p>Let $\text{X}_1$ be the first input vector. This will be randomly mapped onto a matrix of zeros $T$ times using a fixed mapping scheme $[\text{P}_1, \text{P}_2, &mldr;, \text{P}_{\text{R}}]$ in order to form the initial configuration $\text{A}_0^{(1)}$ for the GoL. The transition function $Z$, the rules of GoL, is then applied for $I$ generations:</p><p>$$\text{A}_{1}^{(1)}=\text{Z}(\text{A}_0^{(1)})$$</p><p>$$ \text{A}_{2}^{(1)} = \text{Z}(\text{A}_{1}^{(1)}) $$</p><p>$$ \vdots $$</p><p>$$ \text{A}_{\text{I}}^{(1)} = \text{Z}(\text{A}_{\text{I}-1}^{(1)}) $$</p><p>This constitutes the evolution of the CA given the input $\text{X}_1$. In order to create the state vector we need to vectorize and concatenate the matrices we obtained. Identifying with $\text{A}_{0, 1}^{(1)}$ the first column of $\text{A}_0^{(1)}$, let $c$ be the total number of columns of $\text{A}_0^{(1)}$, then the vectorization of $\text{A}_0^{(1)}$ will be</p><p>$$\text{v}\text{A}_0^{(1)} = [\text{A}_{0, 1}^{(1)}, \text{A}_{0, 2}^{(1)}, &mldr;, \text{A}_{0, c}^{(1)}]$$</p><p>This procedure is done for every timestep $I$, and at the end the vector state $\textbf{x}^{(1)}$ will be</p><p>$$\textbf{x}^{(1)} = [\text{v}\text{A}_0^{(1)}, \text{v}\text{A}_1^{(1)}, &mldr;, \text{v}\text{A}_{I}^{(1)}]$$</p><p>An illustration of this process can be seen in figure.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/10376688/88486881-4561f580-cf81-11ea-8298-25b203609908.png alt=stateharvest></p><p>To feed the second input vector $\text{X}_2$ we use the same mapping created in the first step. Instead of using an initial empty matrix this time we will project the input over the matrix representing the last evolution of the prior step, $\text{A}_{\text{I}}^{(1)}$. The matrix thus obtained is evolved as described above, to obtain the state vectors for the second input vector. This procedure is repeated for every input vector.</p><p>The training is carried out using Ridge Regression.</p><h1 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h1><p>For example we will try to reproduce the 5 bit memory task, described <a href=https://martinuzzifrancesco.github.io/posts/07_gsoc_week/>last week</a>. If you want to follow along and experiment with the model, the data can be found <a href=https://github.com/SciML/ReservoirComputing.jl/files/4978264/5bit200.zip>here</a>: the <code>5bitinput.txt</code> is the input data and the <code>5bitoutput</code> is the desired output. To read the data we can use the following</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>using</span> DelimitedFiles
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>input <span style=color:#f92672>=</span> readdlm(<span style=color:#e6db74>&#34;./5bitinput.txt&#34;</span>, <span style=color:#e6db74>&#39;,&#39;</span>, <span style=color:#66d9ef>Int</span>)
</span></span><span style=display:flex><span>output <span style=color:#f92672>=</span> readdlm(<span style=color:#e6db74>&#34;./5bitoutput.txt&#34;</span>, <span style=color:#e6db74>&#39;,&#39;</span>, <span style=color:#66d9ef>Int</span>)
</span></span></code></pre></div><p>Now that we have the data we can train the model and see if it is capable of solving the 5 bit memory task with a distractor period of 200.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>using</span> ReservoirComputing
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>reca <span style=color:#f92672>=</span> RECA_TwoDim(input, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>110</span>)
</span></span><span style=display:flex><span>W_out <span style=color:#f92672>=</span> ESNtrain(reca, <span style=color:#ae81ff>0.001</span>; train_data <span style=color:#f92672>=</span> convert(<span style=color:#66d9ef>AbstractArray</span>{<span style=color:#66d9ef>Float64</span>}, output))
</span></span><span style=display:flex><span>reca_output <span style=color:#f92672>=</span> RECATDdirect_predict_discrete(reca, W_out, input)
</span></span><span style=display:flex><span>reca_output <span style=color:#f92672>==</span> output
</span></span></code></pre></div><pre tabindex=0><code>true
</code></pre><p>It seems that for architecture used in this example the task is easily solvable. A more deep investigation can be made iterating over different values of reservoir size, permutations and generations, but it can take some time. The results for 100 runs for some of the combinations are given in the table below:</p><p><img loading=lazy src=https://user-images.githubusercontent.com/10376688/88487945-02585000-cf8a-11ea-8a3c-6c34dfb8eef5.png alt=table2></p><p>where (n, m) stands for n = generations and m = permutations. The sizes chosen for the system are 26, 28 and 30. As we can see for some of these parameters the 5 bit memory task is solved 100 times out of 100 runs.</p><p>As always, if you have any questions regarding the model, the package or you have found errors in my post, please don’t hesitate to contact me!</p><h2 id=documentation>Documentation<a hidden class=anchor aria-hidden=true href=#documentation>#</a></h2><p>[1]
Yilmaz, Ozgur. &ldquo;Reservoir computing using cellular automata.&rdquo; arXiv preprint arXiv:1410.0162 (2014).</p><p>[2]
Gardner, Martin. &ldquo;Mathematical games: The fantastic combinations of John Conway’s new solitaire game “life”.&rdquo; Scientific American 223.4 (1970): 120-123.</p><p>[3]
Weisstein, Eric W. &ldquo;Moore Neighborhood.&rdquo; From MathWorld&ndash;A Wolfram Web Resource. <a href=https://mathworld.wolfram.com/MooreNeighborhood.html>https://mathworld.wolfram.com/MooreNeighborhood.html</a></p><p>[4]
Wolfram, Stephen. A new kind of science. Vol. 5. Champaign, IL: Wolfram media, 2002.</p><p>[5]
Margem, Mrwan, and Osman S. Gedik. &ldquo;Feed-forward versus recurrent architecture and local versus cellular automata distributed representation in reservoir computing for sequence memory learning.&rdquo; Artificial Intelligence Review (2020): 1-30.</p><p>[6]
Nichele, Stefano, and Andreas Molund. &ldquo;Deep reservoir computing using cellular automata.&rdquo; arXiv preprint arXiv:1703.02806 (2017).</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://martinuzzifrancesco.github.io/>Francesco Martinuzzi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>